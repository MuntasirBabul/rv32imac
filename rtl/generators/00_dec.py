#!/usr/bin/env python3
import json, os, textwrap
from pathlib import Path

OUT = Path("output")
OUT.mkdir(exist_ok=True)

with open("generators/isa_db.json") as f:
    isa = json.load(f)

# ------------------------------------------------------------------------
# Generate package with all enums
# ------------------------------------------------------------------------
pkg = """package rv32imac_pkg;
  typedef enum logic [4:0] {
    ALU_ADD,  ALU_SUB,  ALU_AND, ALU_OR,  ALU_XOR,
    ALU_SLL,  ALU_SRL,  ALU_SRA, ALU_SLT, ALU_SLTU,
    ALU_COPY                                   // just pass operand
  } alu_op_t;

  typedef enum logic [1:0] { MEM_NONE, MEM_LOAD, MEM_STORE, MEM_FENCE } mem_op_t;
  typedef enum logic [1:0] { BYTE=0, HALF=1, WORD=2 } mem_width_t;
  typedef enum logic [1:0] { BR_NO, BR_EQ, BR_NE, BR_LT, BR_GE, BR_LTU, BR_GEU, BR_ALWAYS } branch_t;
endpackage
"""
(OUT / "rv32imac_pkg.sv").write_text(pkg)

# ------------------------------------------------------------------------
# Generate the big decoder
# ------------------------------------------------------------------------
lines = []
lines += ["// This file is AUTO-GENERATED by generate_rtl.py – DO NOT EDIT",
          "// Generated from isa_db.json",
#          "", "import rv32imac_pkg::*;",
#          "", "always_comb begin",
          "  // default assignments (avoid latches)",
          "  ctrl = '0;",
          "  ctrl.illegal = 1'b1;"]

for inst in isa:
    name = inst["name"]
    opcode = inst.get("opcode", "")
    funct3 = inst.get("funct3", "")
    funct7 = inst.get("funct7", "")
    funct5 = inst.get("funct5", "")
    imm12 = inst.get("imm", "")

    cond = []
    if opcode:   cond.append(f"instr[6:0] == 7'b{opcode}")
    if funct3:   cond.append(f"instr[14:12] == 3'b{funct3}")
    if funct7:   cond.append(f"instr[31:25] == 7'b{funct7}")
    if funct5:   cond.append(f"instr[31:27] == 5'b{funct5}")
    if imm12:    cond.append(f"instr[31:20] == 12'b{imm12}")

    condition = " && ".join(cond) if cond else "1'b1"

    lines.append("")
    lines.append(f"  // {name}")
    lines.append(f"  if ({condition}) begin")
    lines.append(f"    ctrl.illegal = 1'b0;")

    # basic fields
    if inst.get("rd",0):   lines.append("    ctrl.rd_addr  = instr[11:7];")
    if inst.get("rs1",0):  lines.append("    ctrl.rs1_addr = instr[19:15];")
    if inst.get("rs2",0):  lines.append("    ctrl.rs2_addr = instr[24:20];")

    # immediate type
    itype = inst.get("type","R")
    lines.append(f"    ctrl.imm_type = {itype}_TYPE;")

    # ALU
    alu = inst.get("alu","COPY")
    lines.append(f"    ctrl.alu_op   = ALU_{alu};")

    # memory
    if "mem" in inst:
        lines.append(f"    ctrl.mem_op    = MEM_{inst['mem']};")
        if "mem_width" in inst:
            lines.append(f"    ctrl.mem_width = {inst['mem_width']};")
        if "mem_sign" in inst:
            lines.append(f"    ctrl.mem_unsigned = {( 'ZERO' in inst['mem_sign'] )} ;")

    # writeback
    if inst.get("wb",0):   lines.append("    ctrl.wb_en = 1'b1;")

    # branch / jump
    br = inst.get("branch")
    if br:
        lines.append(f"    ctrl.branch = BR_{br};")
    if inst.get("link"):
        lines.append("    ctrl.link   = 1'b1;")

    # M extension
    if inst.get("mul"): lines.append("    ctrl.mul_valid = 1'b1;")
    if inst.get("div"): lines.append("    ctrl.div_valid = 1'b1;")

    lines.append("  end")

# final else for illegal instruction
lines += ["  else begin",
          "    ctrl.illegal = 1'b1;",
#          "  end",
          "  end"]

header = """//==============================================================================
// Auto-generated RV32IMAC decoder + control
//==============================================================================
`ifndef RV32IMAC_DECODE_SVH
`define RV32IMAC_DECODE_SVH

import rv32imac_pkg::*;

package rv32i_decode_pkg;
// Add your own typedefs here if needed
typedef struct packed {
  logic illegal;

  logic [4:0]  rd_addr;
  logic [4:0]  rs1_addr;
  logic [4:0]  rs2_addr;

  logic [2:0]  imm_type;  // 0=I,1=S,2=B,3=U,4=J
  alu_op_t     alu_op;

  mem_op_t     mem_op;
  mem_width_t  mem_width;
  logic        mem_unsigned;

  logic        wb_en;
  branch_t     branch;
  logic        link;

  logic        mul_valid;
  logic        div_valid;
} ctrl_t;

endpackage
`endif
"""

decode_file = "\n".join(lines) + "\n"
(OUT / "rv32imac_decode.svh").write_text(decode_file)

decode_pkg_file = header + "\n"
(OUT / "rv32imac_decode_pkg.sv").write_text(decode_pkg_file)

print("Generation complete!")
print("→ output/rv32imac_pkg.sv")
print("→ output/rv32imac_decode_pkg.sv")
print("→ output/rv32imac_decode.svh  (include this in your decode module)")
