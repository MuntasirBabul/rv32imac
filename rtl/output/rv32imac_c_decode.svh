//==============================================================================
// Auto-generated RV32C (Compressed) Extension Decoder + Expander
// DO NOT EDIT â€“ generated by generators/03_compressed.py
// Supports ALL 40+ compressed instructions (Quadrant 0,1,2)
//==============================================================================

`ifndef RV32IMAC_C_DECODE_SVH
`define RV32IMAC_C_DECODE_SVH

always_comb begin
  // Default: pass through 32-bit instruction unchanged
  instr_32     = instr_raw;
  compressed   = 1'b0;
  illegal_c    = 1'b0;

  if (instr_raw[1:0] != 2'b11) begin                    // 16-bit instruction
    compressed = 1'b1;
    case (instr_raw[1:0])
      2'b00: begin                                     // Quadrant 0
        case (instr_raw[15:13])
          3'b000: begin                              // C.ADDI4SPN
            if (instr_raw[12:5] == 8'b0) illegal_c = 1'b1;
            else instr_32 = {5'b0,instr_raw[10:7],instr_raw[12:11],instr_raw[5],instr_raw[6],2'b00,5'd2,3'b000,instr_raw[4:2],2'b01};
          end
          3'b010: instr_32 = {4'b0,instr_raw[8:7],instr_raw[12:10],instr_raw[6],2'b00,instr_raw[4:2],3'b010,instr_raw[9:7],7'b0000011}; // C.LW
          3'b110: instr_32 = {4'b0,instr_raw[8:7],instr_raw[12:10],instr_raw[6],2'b00,instr_raw[11:9],instr_raw[4:2],3'b010,instr_raw[9:7],7'b0100011}; // C.SW
          default: illegal_c = 1'b1;
        endcase
      end

      2'b01: begin                                     // Quadrant 1
        case (instr_raw[15:13])
          3'b000: begin                              // C.ADDI / C.NOP
            instr_32 = {{7{instr_raw[12]}},instr_raw[6:2],instr_raw[11:7],3'b000,instr_raw[11:7],7'b0010011};
          end
          3'b001, 3'b101: begin                      // C.JAL / C.J
            instr_32 = {{12{instr_raw[12]}},instr_raw[8],instr_raw[10:9],instr_raw[6],instr_raw[7],instr_raw[2],instr_raw[11],instr_raw[5:3],{9{instr_raw[12]}},4'b0,
                        (instr_raw[15:13]==3'b001)?5'd1:5'd0,7'b1101111};
          end
          3'b010: instr_32 = {{7{instr_raw[12]}},instr_raw[6:2],5'd0,3'b000,instr_raw[11:7],7'b0010011}; // C.LI
          3'b011: begin
            if (instr_raw[11:7] == 5'd2)              // C.ADDI16SP
              instr_32 = {{3{instr_raw[12]}},instr_raw[4:3],instr_raw[5],instr_raw[2],instr_raw[6],4'b0,5'd2,3'b000,5'd2,7'b0010011};
            else                                      // C.LUI
              instr_32 = {{15{instr_raw[12]}},instr_raw[6:2],instr_raw[11:7],7'b0110111};
          end
          3'b100: begin
            case (instr_raw[11:10])
              2'b00, 2'b01:                          // C.SRLI / C.SRAI
                instr_32 = {7'b0000000,instr_raw[12],instr_raw[6:2],instr_raw[9:7],3'b101,instr_raw[9:7],7'b0010011};
              2'b10:                                   // C.ANDI
                instr_32 = {{7{instr_raw[12]}},instr_raw[6:2],instr_raw[9:7],3'b111,instr_raw[9:7],7'b0010011};
              2'b11: begin
                case (instr_raw[12:10])
                  3'b011: instr_32 = {12'b0,instr_raw[11:7],instr_raw[6:2],instr_raw[9:7],3'b111,instr_raw[9:7],7'b0110011}; // C.AND
                  3'b010: instr_32 = {12'b0,instr_raw[11:7],instr_raw[6:2],instr_raw[9:7],3'b110,instr_raw[9:7],7'b0110011}; // C.OR
                  3'b001: instr_32 = {12'b0,instr_raw[11:7],instr_raw[6:2],instr_raw[9:7],3'b100,instr_raw[9:7],7'b0110011}; // C.XOR
                  3'b000: instr_32 = {7'b0100000,instr_raw[6:2],instr_raw[11:7],instr_raw[9:7],3'b000,instr_raw[9:7],7'b0110011}; // C.SUB
                  default: illegal_c = 1'b1;
                endcase
              end
              default: illegal_c = 1'b1;
            endcase
          end
          3'b110, 3'b111: begin                      // C.BEQZ / C.BNEZ
            instr_32 = {{4{instr_raw[12]}},instr_raw[6:5],instr_raw[2],instr_raw[11:10],instr_raw[4:3],instr_raw[9:7],
                        (instr_raw[15:13]==3'b110)?3'b000:3'b001,instr_raw[9:7],7'b1100011};
          end
          default: illegal_c = 1'b1;
        endcase
      end

      2'b10: begin                                     // Quadrant 2
        case (instr_raw[15:13])
          3'b000: begin                              // C.SLLI
            if (instr_raw[12]) illegal_c = 1'b1;
            else instr_32 = {7'b0000000,instr_raw[6:2],instr_raw[11:7],3'b001,instr_raw[11:7],7'b0010011};
          end
          3'b010: instr_32 = {4'b0,instr_raw[3:2],instr_raw[12],instr_raw[6:4],2'b00,5'd2,3'b010,instr_raw[11:7],7'b0000011}; // C.LWSP
          3'b100: begin
            if (instr_raw[12] == 1'b0) begin
              if (instr_raw[6:2] == 5'b0)           // C.JR
                instr_32 = {12'b0,instr_raw[11:7],5'b0,3'b000,5'd1,7'b1100111};
              else                                   // C.MV
                instr_32 = {7'b0,instr_raw[6:2],5'b0,3'b000,instr_raw[11:7],7'b0110011};
            end else begin
              if (instr_raw[6:2] == 5'b0)           // C.JALR
                instr_32 = {12'b0,instr_raw[11:7],5'b0,3'b000,5'd1,7'b1100111};
              else                                   // C.ADD
                instr_32 = {7'b0,instr_raw[6:2],instr_raw[11:7],3'b000,instr_raw[11:7],7'b0110011};
            end
          end
          3'b110: instr_32 = {4'b0,instr_raw[8:7],instr_raw[12],instr_raw[6:2],5'd2,3'b010,instr_raw[11:9],2'b00,7'b0100011}; // C.SWSP
          default: illegal_c = 1'b1;
        endcase
      end

      default: illegal_c = 1'b1;
    endcase
  end

  // Final illegal if hint/reserved
  if (compressed && instr_32 == 32'b0) illegal_c = 1'b1;
end

`endif
