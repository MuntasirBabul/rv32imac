//==============================================================================
// Auto-generated Immediate Extractor for RV32IMAC (I/S/B/U/J + Compressed ready)
// DO NOT EDIT – generated by generators/01_imm.py
//==============================================================================

`ifndef RV32IMAC_IMM_SVH
`define RV32IMAC_IMM_SVH

import rv32imac_pkg::*;

// --------------------------------------------------------------------------
// Extract and sign-extend immediate based on ctrl.imm_type
// --------------------------------------------------------------------------
module imm_extractor (
    input  logic [31:0] instr,       // raw instruction (32-bit or expanded)
    input  logic  [2:0] imm_type,    // from decoder: 0=I, 1=S, 2=B, 3=U, 4=J
    output logic [31:0] imm
);

  always_comb begin
    case (imm_type)
      3'd0: begin // I-type  [31:20] → sign-extend
        imm = {{20{instr[31]}}, instr[31:20]};
      end
      3'd1: begin // S-type  [31:25|11:7] → sign-extend
        imm = {{20{instr[31]}}, instr[31:25], instr[11:7]};
      end
      3'd2: begin // B-type  [31|7|30:25|11:8] → sign-extend + <<1
        imm = {{19{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};
      end
      3'd3: begin // U-type  [31:12] → <<12
        imm = {instr[31:12], 12'b0};
      end
      3'd4: begin // J-type  [31|19:12|20|30:21] → sign-extend + <<1
        imm = {{11{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};
      end
      default: imm = 32'd0;
    endcase
  end

  // Optional: compressed immediates (you will use this later with C extension)
  // Just leave the logic here – it costs zero area when not used
  logic [31:0] c_imm;
  always_comb begin
    case (instr[1:0])
      2'b01: begin // Quadrant 1
        case (instr[15:13])
          3'b000: c_imm = {{23{instr[12]}}, instr[12], instr[6:5], instr[2], instr[11:10], instr[4:3], 3'b000};      // C.ADDI4SPN
          3'b010: c_imm = {25'b0, instr[5:3], instr[12:10], instr[6], 2'b00};                                           // C.LW
          3'b110: c_imm = {25'b0, instr[5:3], instr[12:10], instr[6], 2'b00};                                           // C.SW
          default: c_imm = 32'd0;
        endcase
      end
      2'b10: begin // Quadrant 2
        case (instr[15:13])
          3'b000: c_imm = {{27{instr[12]}}, instr[6:2]};                     // C.ADDI / C.SLLI etc.
          3'b100: c_imm = (instr[12] ? {{27{instr[12]}}, instr[6:2]} : 32'd0); // C.SRLI/C.SRAI (nzimm)
          default: c_imm = 32'd0;
        endcase
      end
      default: c_imm = 32'd0;
    endcase
  end

endmodule

`endif
